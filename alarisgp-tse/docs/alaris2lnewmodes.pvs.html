<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: alaris2lnewmodes.pvs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: alaris2lnewmodes.pvs</h1>






    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
%%
% @module alaris_th
% @author Michael Harrison and Paolo Masci (QMUL and Newcastle University)
% @date 4/8/2015
% @description includes reals, accelerators and only updates vtbi and time as exits vtbi mode - bug found when checking properties
%              relating to visibility of vtbi and time and when switching off
%              adds stronger constraints ok keys to allow proof of properties relating to
%              function displays
%%
alaris_th [
   maxrate  : posnat, %{maxrate: posnat | maxrate > 1000},
   maxinfuse: posnat, %{maxinfuse: posnat |  maxinfuse >= 3000 }, % maxtime = maxinfuse needed for proving maxinfuse_over_time_lemma and vtbi_over_time_lemma
   infusemin: { infusemin: posreal | infusemin <= maxinfuse },
   timeout  : posnat,
   shorttimeout : {shorttimeout: posnat | shorttimeout < timeout},
   maxtime  : { maxtime: posnat | maxtime > timeout AND maxtime >= maxinfuse },
   bat_max : {bat_max: posnat | bat_max+1 < maxtime},
   bat_min: {bat_min: posnat | bat_min < bat_max}
]: THEORY
 BEGIN IMPORTING pump_th[maxrate, maxinfuse, infusemin, timeout, shorttimeout, maxtime, bat_max, bat_min]

  %%
  % @type state
  % @description Interactor main, aggregates pump via device
  % @property {pump} device Device controller and infusion process model
  % @property {iline} topline Topline of the display
  % @property {imid} middisp Central part of the display
  % @property {o_menu} optionsmenu Options menu
  % @property {ibagscursor} bagscursor Bags display
  % @property {qcurse} qcursor Cursor for selecting bags
  % @property {abags} bagsval Bags values
  % @property {ifunctions} fndisp1 Soft function 1
  % @property {ifunctions} fndisp2 Soft function 2
  % @property {ifunctions} fndisp3 Soft function 3
  % @property {boolean} runlight LED light indicating a running infusion
  % @property {boolean} pauselight LED light indicating a paused infusion
  % @property {boolean} ac_light LED light indicating connection to mains
  % @property {battery_light} boolean LED light indicating running on battery
  % @property {entrymode} emodes Data entry mode
  % @property {boolean} rlock Whether the keypad is locked
  % @property {boolean} rdisabled Whether the keypad is disabled
  % @property {ivols} newvtbi VTBI value during data entry
  % @property {irates} newrate Rate value during data entry
  % @property {itimes} newtime Time value during data entry
  % @property {presstime} pressed Whether a button is pressed
  % @property {steprate} current_sr Increment step for rate during data entry
  % @property {stepvol} current_sv Increment step for volume during data entry
  % @property {steptime} current_st Increment step for time during data entry
  % @property {chev_buttons} which_press Which button is pressed
  %%
  state: TYPE = [#
    device : pump,
    topline: iline, % [vis]
    middisp: imid,  % [vis]
    optionsmenu: o_menu,
    bagscursor: ibagscursor, % [vis]
    qcursor: qcurse, % [vis]
    bagsval: abags, % [vis]
    fndisp1: ifunctions, % [vis]
    fndisp2: ifunctions, % [vis]
    fndisp3: ifunctions, % [vis]
    runlight: boolean, % [vis]
    pauselight: boolean, % [vis]
    ac_light: boolean, % [vis]
    battery_light: boolean,
    entrymode: emodes,
    rlock: boolean,
    rdisabled: boolean,
    newvtbi: ivols,
    newrate: irates,
    newtime: itimes,
    pressed: presstime,
    current_sr: steprate,
    current_sv: stepvol,
    current_st: steptime,
    which_press: chev_buttons
  #]

  %%
  % @function decrement
  % @description Utility function for updating state attribute 'pressed'
  % @param {presstime} t Amount of time the button can be pressed continuously without changing step increment
  % @param {delta} n Discrete time advance
  % @returns {presstime} Remaining amount of time the button can be pressed continuously without changing step increment
  % @memberof module:alaris_th
  %%
  decrement(t: presstime, n: delta): presstime = IF t-n>=0 THEN t-n ELSE t ENDIF

  %%
  % @function trim_rate
  % @description Utility function, limits rate value to maxrate
  % @param {real} x Rate value
  % @returns {irates} Rate value between [0..maxrate]
  % @memberof module:alaris_th
  %%
  trim_rate(x: real): irates = IF x>maxrate THEN maxrate ELSIF x<0 THEN 0 ELSE x ENDIF

  %%
  % @function trim_vtbi
  % @description Utility function, limits vtbi value to maxvtbi
  % @param {real} x VTBI value
  % @returns {ivols} VTBI value between [0..maxvtbi]
  % @memberof module:alaris_th
  %%
  trim_vtbi(x: real): ivols = IF x>maxinfuse THEN maxinfuse ELSIF x<0 THEN 0 ELSE x ENDIF

  %%
  % @function trim_time
  % @description Utility function, limits time value to maxtime
  % @param {real} x Time value
  % @returns {itimes} Time value between [0..maxtime]
  % @memberof module:alaris_th
  %%
  trim_time(x: real): itimes = IF x>maxtime THEN maxtime ELSIF x<0 THEN 0 ELSE x ENDIF

  %%
  % @function ceil_rate
  % @description Utility function, truncates a rate value by removing the fractional part from the value
  % @param {real} x Rate value
  % @returns {irates} Truncated rate value
  % @memberof module:alaris_th
  %%
  ceil_rate(x: irates): irates = ceiling(x)

  %%
  % @function ceil_vtbi
  % @description Utility function, truncates a vtbi value by removing the fractional part from the value
  % @param {real} x VTBI value
  % @returns {irates} Truncated VTBI value
  % @memberof module:alaris_th
  %%
  ceil_vtbi(x: ivols): ivols = ceiling(x)

  %%
  % @function ceil_time
  % @description Utility function, truncates a time value by removing the fractional part from the value
  % @param {real} x Time value
  % @returns {irates} Truncated time value
  % @memberof module:alaris_th
  %%
  ceil_time(x: itimes): itimes = ceiling(x)

  %%
  % @function init?
  % @description Iniitialization predicate, checks if the model is in the initial state
  % @param {state} st Current state
  % @returns {bool} True if parameter st is the initial state, false otherwise
  % @memberof module:alaris_th
  %%
  init?(st: state): bool =
    init?(st`device) and
    topline(st) = dispblank and
    middisp(st)(drate) = FALSE and
    middisp(st)(dvtbi) = FALSE and
    middisp(st)(dtime) = FALSE and
    middisp(st)(dvol) = FALSE and
    middisp(st)(dbags) = FALSE and
    middisp(st)(dkvorate) = FALSE and
    middisp(st)(dquery) = FALSE and
    middisp(st)(dnewvtbi) = FALSE and
    middisp(st)(dnewrate) = FALSE and
    middisp(st)(dnewtime) = FALSE and
    bagscursor(st) = midbag and
    qcursor(st) = dlock and
    bagsval(st)(0) = 0 and
    bagsval(st)(1) = 50 and
    bagsval(st)(2) = 100 and
    bagsval(st)(3) = 200 and
    bagsval(st)(4) = 250 and
    bagsval(st)(5) = 500 and
    bagsval(st)(6) = 1000 and
    bagsval(st)(7) = 1500 and
    bagsval(st)(8) = 2000 and
    bagsval(st)(9) = 3000 and
    fndisp1(st) = fnull and
    fndisp2(st) = fnull and
    fndisp3(st) = fnull and
    runlight(st) = FALSE and
    pauselight(st) = FALSE and
    ac_light(st) = FALSE and
    battery_light(st) = FALSE and
    entrymode(st) = nullmode and
    rlock(st) = false and
    rdisabled(st) = false and
    newvtbi(st) = 0 and
    newrate(st) = 0 and
    newtime(st) = 0 and
    which_press(st) = nob and
    current_sv(st) = small_step and
    current_sr(st) = small_step and
    current_st(st) = small_step and
    pressed(st) = maxpress

  %%
  % @function no_button_down
  % @description Utility function to check if a button is currently pressed
  % @param {state} st Current state
  % @returns {bool} True if a button is pressed, false otherwise
  % @memberof module:alaris_th
  %%
  no_button_down(st: state): bool =
    which_press(st) = nob AND pressed(st) = maxpress

  %%
  % @function release_key
  % @description Utility function to reset state attributes related to key presses
  % @param {state} st Current state
  % @returns {state} State where state attributes related to key presses have been reset
  % @memberof module:alaris_th
  %%
  release_key(st:state): state =
    st WITH [ which_press := nob,
              current_sr := small_step,
              current_sv := small_step,
              current_st := small_step,
              pressed := maxpress ]

  %%
  % @function dispblank?
  % @description Utility function, checks whether the display is switched off
  % @param {state} st Current state
  % @returns {bool} True if the display is switched off, false otherwise
  % @memberof module:alaris_th
  %%
  dispblank?(st: state): bool = st`topline = dispblank <=> NOT device(st)`powered_on?

  %%
  % @function per_switch
  % @description Permission predicate, associated with action for switching between battery and mains
  % @param {state} st Current state
  % @returns {bool} True if the pump is powered on and can be switched between battery and mains
  % @memberof module:alaris_th
  %%
  per_switch(st: state): boolean =
         device(st)`powered_on? AND no_button_down(st) AND
           ((device(st)`ac_connect AND ac_light(st) AND NOT(battery_light(st)))
	   OR (NOT device(st)`ac_connect AND NOT ac_light(st) AND
	             battery_light(st)))



  %%
  % @function switch_from_battery_low
  % @description Switch to mains when battery was low
  % @param {state} st Current state
  % @returns {state} Next state
  % @memberof module:alaris_th
  %%
  switch_from_battery_low(st: state): state =
      st WITH [ topline := COND device(st)`infusing? AND NOT device(st)`kvoflag -> infusing,
                                device(st)`infusing? AND device(st)`kvoflag -> dispkvo,
                                NOT device(st)`infusing? & device(st)`infusionrate = 0
                                        -> setrate,
                                ELSE -> holding
                           ENDCOND,
                middisp :=
                  COND NOT device(st)`infusing? ->
                           LAMBDA(x: imid_type):
		            COND x = drate -> TRUE,
			         x = dvtbi -> device(st)`vtbi /= 0,
			         x = dtime -> device(st)`vtbi /= 0,
				 x = dvol -> TRUE,
                  		 ELSE -> FALSE ENDCOND,
                        ELSE ->
                          LAMBDA(x: imid_type):
                           COND x = drate -> NOT device(st)`kvoflag,
                                x = dkvorate -> device(st)`kvoflag,
                                (x = dvtbi) OR (x = dvol) OR (x = dtime) -> TRUE,
				ELSE -> FALSE ENDCOND
                        ENDCOND,
                fndisp1 := fvol,
		fndisp2 := COND device(st)`infusing? AND device(st)`kvoflag -> fnull,
                           ELSE -> fvtbi ENDCOND,
                fndisp3 := fnull,
		entrymode  := COND NOT device(st)`infusing? -> rmode,
                                   ELSE -> infusemode
                              ENDCOND,
                device := mains_switch(st`device),
                ac_light := TRUE,
                battery_light := FALSE
	        ]

  %%
  % @function switch_battery_low
  % @description Switch to battery, case battery low
  % @param {state} st Current state
  % @returns {state} Next state
  % @memberof module:alaris_th
  %%
  switch_battery_low(st: state): state =
       st WITH [ topline := batterylow,
                middisp := LAMBDA(x: imid_type): FALSE,
                fndisp1 := fnull,
                fndisp2 := fnull,
		fndisp3 := fcancel,
              	entrymode   := nullmode,
                device := mains_switch(st`device),
                ac_light := FALSE,
                battery_light := TRUE ]

  %%
  % @function switch
  % @description Switch from/to battery and mains
  % @param {state} st Current state
  % @returns {state} Next state
  % @memberof module:alaris_th
  %%
  switch(st: (per_switch)): state =
     COND
       device(st)`ac_connect -> switch_battery_low(st),
       NOT device(st)`ac_connect & (topline(st) = batterylow) ->
                    switch_from_battery_low(st),
       ELSE -> st WITH [device := mains_switch(st`device),
                    ac_light := TRUE,
                    battery_light := FALSE]
      ENDCOND

% fitting the giving set

per_fit_set(st: state): boolean =
      device(st)`powered_on? AND no_button_down(st)
fit_to_hold(st: state): state =
   st WITH [ topline := COND device(st)`infusionrate = 0 -> setrate,
                           ELSE -> holding ENDCOND,
             middisp := LAMBDA(x: imid_type): (x = drate) OR
	                             ( x = dvol),
             fndisp1 := fvol,
	     fndisp2 := fvtbi,
             fndisp3 := fnull,
	     entrymode  := rmode,
	     device  := resetElapsed(device(st))]

fit_set(st: (per_fit_set)): state =
      COND
        topline(st) = setnotfitted & NOT device(st)`infusing? ->
                    fit_to_hold(st),
        ELSE -> st
      ENDCOND WITH [ device := connect_set(st`device)]

% switching the device on

 per_on(st:state): bool =
    (NOT device(st)`powered_on? AND topline(st) = dispblank) OR
    (device(st)`powered_on? AND topline(st) /= dispblank)

  on_case_infusionstatusblank(st: state): state =
         st WITH [ device := on(st`device),
                   topline := COND
                               device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0
                                    OR device(st)`time /= 0 -> clearsetup,
                               ELSE -> setrate
                              ENDCOND,
                   middisp := LAMBDA(x: imid_type):
                                COND x = drate -> TRUE,
                                     x = dvtbi -> device(st)`vtbi /= 0,
                                     x = dtime -> (device(st)`vtbi /= 0) OR
                                                  (device(st)`infusionrate /= 0),
                                     x = dvol  -> TRUE,
                                    ELSE -> FALSE ENDCOND,
                   fndisp1 := COND
                               device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0
                                    OR device(st)`time /= 0 -> fclear,
                               ELSE -> fvol
                              ENDCOND,
                   fndisp2 := COND
                                device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0
                                     OR device(st)`time /= 0 -> fnull,
                                ELSE -> fvtbi
                              ENDCOND,
                   fndisp3 := COND
                                device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0
                                     OR device(st)`time /= 0 -> fkeep,
                                ELSE -> fnull
                              ENDCOND,
                   entrymode := COND
                                  device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0
                                      OR device(st)`time /= 0 -> nullmode,
                                  ELSE -> rmode
                                ENDCOND,
                   rdisabled := FALSE,
                   ac_light := device(st)`ac_connect,
                   battery_light := NOT device(st)`ac_connect,
                   pauselight := TRUE,
                   runlight := FALSE,
                   which_press := nob,
                   current_sv := small_step,
                   current_sr := small_step,
                   current_st := small_step,
                   pressed := maxpress ]

  on_case_infusionstatusNOTblank(st: state): state =
     st WITH [
        device := on(st`device),
        topline := dispblank,
        middisp := LAMBDA(x: imid_type): FALSE,
        bagscursor := midbag,
        entrymode  := nullmode,
        ac_light := FALSE,
        battery_light := FALSE,
        pauselight := FALSE,
        runlight   := FALSE,
        fndisp1    := fnull,
        fndisp2    := fnull,
        fndisp3    := fnull ]


  on(st: (per_on)): state =
   COND
     NOT device(st)`powered_on? AND topline(st) = dispblank -> on_case_infusionstatusblank(st),
     device(st)`powered_on? AND topline(st) /= dispblank-> on_case_infusionstatusNOTblank(st)
   ENDCOND


% starting the infusion when the device is paused

  per_run(st: state): bool = per_start(st`device) AND
                              topline(st) = holding AND
                              entrymode(st) = rmode AND no_button_down(st)


  run_cond_NZ(st: {st: state | per_run(st)}): state =
    st WITH [ device := start(st`device),
              topline := infusing,
              middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvtbi) OR (x = dvol) OR (x = dtime),
              fndisp1 := fvol,
              fndisp2 := fvtbi,
              fndisp3 := fnull,
              entrymode  := infusemode,
              runlight := TRUE,
              pauselight := FALSE ]

  run_check_rlock(st: (per_run)): state =
     st WITH [topline := lockrate,
              middisp := LAMBDA (x: imid_type): FALSE,
              fndisp1 := fyes,
              fndisp2 := fnull,
              fndisp3 := fno,
              entrymode := nullmode]

  run_cond_vtbi0_kvoflag(st: {st: state | per_run(st)}): state =
     st WITH [ device := start(st`device),
               topline := vtbidone,
               middisp := LAMBDA(x: imid_type): FALSE,
               fndisp1 := fnull,
               fndisp2 := fnull,
               fndisp3 := fcancel,
               runlight := true,
               pauselight := false,
               entrymode  := nullmode]

  run_cond_vtbi0_NOTkvoflag(st: {st: state | per_run(st)}): state =
       st WITH [ device := start(st`device),
                 topline := setvtbi,
                 middisp := LAMBDA(x: imid_type): FALSE,
                 fndisp1 := fnull,
                 fndisp2 := fvtbi,
                 fndisp3 := fcancel,
                 entrymode  := nullmode]



  run_cond_setnotfitted(st: {st: state | per_run(st)}): state =
       st WITH [ topline := setnotfitted,
                 middisp := LAMBDA(x: imid_type): FALSE,
                 fndisp1 := fnull,
                 fndisp2 := fnull,
                 fndisp3 := fcancel,
                 entrymode  := nullmode]

  run(st: {st: state | per_run(st)}): state =
      COND device(st)`vtbi /= 0	&
                device(st)`infusionrate /= 0 & rlock(st) &
                device(st)`set_fitted
                     -> run_cond_NZ(st),
           device(st)`vtbi /= 0	&
                device(st)`infusionrate /= 0 & NOT rlock(st) &
                 device(st)`set_fitted
                     -> run_check_rlock(st),
           device(st)`vtbi = 0 & device(st)`kvoflag &
                  device(st)`set_fitted     -> run_cond_vtbi0_kvoflag(st),
           device(st)`vtbi = 0 & NOT device(st)`kvoflag &
                 device(st)`set_fitted -> run_cond_vtbi0_NOTkvoflag(st),
           NOT device(st)`set_fitted -> run_cond_setnotfitted(st)
      ENDCOND

% pausing the device when infusing
   per_pause(st: state): bool =
       per_pause(st`device) AND
      ((((topline(st) = infusing) OR (topline(st) = dispkvo)) & entrymode(st) = infusemode) OR
       ((topline(st) = dispvtbi) & ((entrymode(st) = vtmode) OR (entrymode(st) = bagmode))) OR
       (topline(st) = volume & entrymode(st) = nullmode) OR
       (topline(st) = locked & entrymode(st) = infusemode))


   pause(st: {st: state | per_pause(st)}): state =
       st
         WITH [device := pause(st`device),
               topline := holding,
               middisp
                 := LAMBDA (x: imid_type):
                      COND (x = drate) OR (x = dvol) -> TRUE,
                           (x = dvtbi) OR (x = dtime) -> (device(st)`vtbi /= 0),
                           ELSE -> FALSE
                      ENDCOND,
               fndisp1 := fvol,
               fndisp2 := fvtbi,
               fndisp3 := fnull,
               entrymode := rmode,
               pauselight := TRUE,
               runlight := FALSE]

% the query action invokes menu for additional functions
  per_query(st: state): bool =
         ((((topline(st) = holding OR topline(st) = setrate) & entrymode(st) = rmode) & NOT device(st)`infusing?) OR
                                ((topline(st) = infusing & entrymode(st) = infusemode) & device(st)`infusing? &
                                  NOT device(st)`kvoflag)) AND
                                device(st)`powered_on? AND no_button_down(st)

  query(st: {st: state | per_query(st)}): state =
          st WITH [ qcursor := 0,
                    topline := options,
                    middisp := LAMBDA(x: imid_type): x = dquery,
		    fndisp1 := fok,
          	    fndisp2 := fnull,
		    fndisp3 := fquit,
		    entrymode   := qmode,
                    optionsmenu :=
                      COND
                        device(st)`infusing? AND NOT rdisabled(st) AND
                        rlock(st)->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> ratelock,
                             x=1 -> dosingsumm,
                             x=2 -> adjalarm,
                             x=3 -> pumpdetails,
                             ELSE -> optionblank
                           ENDCOND,
                        device(st)`infusing? AND NOT rdisabled(st) AND
                        NOT rlock(st) ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> rateunlock,
                             x=1 -> dosingsumm,
                             x=2 -> adjalarm,
                             x=3 -> pumpdetails,
                             ELSE -> optionblank
                           ENDCOND,
                         device(st)`infusing? AND rdisabled(st) ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> dosingsumm,
                             x=1 -> adjalarm,
                             x=2 -> pumpdetails,
                             ELSE -> optionblank
                           ENDCOND,
                          NOT device(st)`infusing? AND NOT rdisabled(st) AND
                          NOT rlock(st) ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> ratelock,
                             x=1 -> dosingsumm,
                             x=2 -> infusionsetup,
                             x=3 -> setvtbiovertime,
                             x=4 -> adjalarm,
                             x=5 -> disableratelock,
                             x=6 -> pumpdetails
                           ENDCOND,
                          NOT device(st)`infusing? AND NOT rdisabled(st) AND
                          rlock(st) ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> rateunlock,
                             x=1 -> dosingsumm,
                             x=2 -> infusionsetup,
                             x=3 -> setvtbiovertime,
                             x=4 -> adjalarm,
                             x=5 -> disableratelock,
                             x=6 -> pumpdetails
                           ENDCOND,
                          NOT device(st)`infusing? AND rdisabled(st)  ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> dosingsumm,
                             x=1 -> infusionsetup,
                             x=2 -> setvtbiovertime,
                             x=3 -> adjalarm,
                             x=4 -> enableratelock,
                             x=5 -> pumpdetails,
                             ELSE -> optionblank
                           ENDCOND
                      ENDCOND,
                    device  := resetElapsed(device(st)) ]


% the tick function which describes the evolution of the process or elapsed time when the device is paused

  per_tick(st: state): bool =
      per_tick(device(st)) AND
        ((NOT device(st)`infusing? AND no_button_down(st) AND
           (((entrymode(st) = rmode) &
             (((topline(st) = holding OR topline(st) = setrate) & middisp(st)(dvol)) OR
              (topline(st) = locked & rlock(st)))) OR
             (middisp(st)(dnewvtbi) & middisp(st)(dnewtime) & middisp(st)(dnewrate) &
               ((entrymode(st) = vttmode) OR (entrymode(st) = ttmode)) &
                 (topline(st) = vtbitime)) OR
             (topline(st) = setvtbi AND entrymode(st) = nullmode) OR
           ((((entrymode(st) = vtmode) & middisp(st)(dnewvtbi)) OR
              (entrymode(st) = bagmode) OR
              (entrymode(st) = tbagmode)) & (topline(st) = dispvtbi)) OR
           (((topline(st) = attention) OR (topline(st) = volume) OR
             (topline(st) = setnotfitted) OR
             ((topline(st) = batterylow) AND NOT device(st)`ac_connect) OR
             (topline(st) = dispinfo)) & (entrymode(st) = nullmode)) OR
         ((entrymode(st) = qmode) & (topline(st) = options)))) OR
% infusing
         (device(st)`infusing? AND no_button_down(st) AND
               ((entrymode(st) = infusemode) &
               (NOT device(st)`kvoflag &
               (((topline(st) = infusing) & middisp(st)(dtime) & middisp(st)(dvtbi) &
                                            middisp(st)(drate) & middisp(st)(dvol)) OR
               ((((entrymode(st) = vtmode) & middisp(st)(dnewvtbi))) & (topline(st) = dispvtbi)) OR
               (topline(st) = locked) OR
               ((entrymode(st) = nullmode) & ((topline(st) = volume) OR
                                        (topline(st) = dispinfo) OR (topline(st) = batterylow))) OR
               ((entrymode(st) = qmode) & (topline(st) = options)))) OR
               (device(st)`kvoflag &
                ((topline(st) = dispkvo) & middisp(st)(dtime) & middisp(st)(dkvorate) &
                                  middisp(st)(dvol) & middisp(st)(dvtbi)) OR
               (((topline(st) = vtbidone) OR (topline(st) = batterylow AND NOT device(st)`ac_connect)) AND (entrymode(st) = nullmode))))))


    tick_case_holding_volume_etc_elapseLTtimeout
     (st: {st: state | per_tick(device(st))}): state =
      st WITH [ device := tick(st`device)]

    tick_case_holding_volume_etc_elapseLTtimeoutlocked
     (st: {st: state | per_tick(device(st))}): state =
      st WITH [ device := tick(st`device),
                topline := COND
                             entrymode(st) = qmode -> options,
                             entrymode(st) /= qmode &
                              device(st)`infusionrate = 0
                                  -> setrate,
                             ELSE -> holding
                           ENDCOND,
                middisp
                 := LAMBDA (x: imid_type):
                      COND (x = drate) OR (x = dvol) -> TRUE,
                           (x = dvtbi) OR (x = dtime) -> (device(st)`vtbi /= 0),
                           ELSE -> FALSE
                      ENDCOND,
               fndisp1 := COND
                             entrymode(st) = qmode -> fok,
                             ELSE -> fvol
                           ENDCOND,
               fndisp2 := COND
                             entrymode(st) = qmode -> fnull,
                             ELSE -> fvtbi
                           ENDCOND,
               fndisp3 := COND
                             entrymode(st) = qmode -> fquit,
                             ELSE -> fnull
                           ENDCOND]

    tick_case_holding_volume_etc_elapseEQtimeout
      (st: {st: state | per_tick(device(st))}): state =
      st WITH [ device := tick(st`device),
                topline := attention,
                middisp := LAMBDA(x: imid_type): FALSE,
                fndisp1 := fnull,
                fndisp2 := fnull,
		fndisp3 := fcancel,
              	entrymode   := nullmode ]

    tick_case_battery_warning
      (st: {st: state | per_tick(device(st))}): state =
      st WITH [ device := tick(st`device),
                topline := batterylow,
                middisp := LAMBDA(x: imid_type): FALSE,
                fndisp1 := fnull,
                fndisp2 := fnull,
		fndisp3 := fcancel,
              	entrymode   := nullmode ]

tick_case_holding_volume_etc_elapseEQshorttimeout
      (st: {st: state | per_tick(device(st))}): state =
      LET newdevice = tick(device(st)) IN
      st WITH [ device := newdevice,
                topline := COND
                           device(st)`infusionrate = 0 -> setrate,
                           ELSE -> holding
                           ENDCOND,
                middisp := LAMBDA(x: imid_type):
 		             COND x = drate -> TRUE,
			          x = dvtbi ->newdevice`vtbi /= 0,
				  x = dvol  -> TRUE,
              			  x = dtime -> newdevice`vtbi /= 0,
				  ELSE -> FALSE ENDCOND,
                fndisp1 := fvol,
                fndisp2 := fvtbi,
		fndisp3 := fnull,
              	entrymode   := rmode ]

    tick_case_infuse_infusionrateLTvtbi(st: {st: state | per_tick(device(st))}): state =
       st WITH [device := tick(st`device)]

     tick_case_infuse_infusionrateLTvtbilocked(st: {st: state | per_tick(device(st))}): state =
       st WITH [device := tick(st`device),
                topline := infusing,
                middisp := LAMBDA(x: imid_type):
                            COND x = drate -> TRUE,
                                 x = dvtbi -> TRUE,
				 x = dvol  -> TRUE,
				 x = dtime -> TRUE,
				 ELSE -> FALSE ENDCOND,
                fndisp1 := fvol,
                fndisp2 := fvtbi,
                fndisp3 := fnull,
                entrymode  := infusemode]

tick_case_infuse_infusionrateEQvtbi_kvoflag(st: {st: state | per_tick(device(st))}): state =
      st WITH [device := tick(st`device)]

    tick_case_infuse_infusionrateEQvtbi_notkvoflag(st: {st: state | per_tick(device(st))}): state =
      release_key(st) WITH [ device := tick(st`device),
                topline := vtbidone,
                middisp := LAMBDA(x: imid_type): FALSE,
                fndisp1 := fnull,
                fndisp2 := fnull,
		fndisp3 := fcancel,
              	entrymode   := nullmode ]

    tick(st: (per_tick)): state =
      IF
       NOT device(st)`ac_connect AND
               device(st)`battery <= bat_min THEN tick_case_battery_warning(st)
      ELSE
        IF NOT device(st)`infusing? THEN
           COND
            (device(st)`elapse >= timeout)
                    -> tick_case_holding_volume_etc_elapseEQtimeout(st),
            (device(st)`elapse >= shorttimeout) &
                    (device(st)`elapse < timeout)
                    -> tick_case_holding_volume_etc_elapseEQshorttimeout(st),
            (device(st)`elapse < shorttimeout) ->
               COND
                topline(st) = locked ->
                   tick_case_holding_volume_etc_elapseLTtimeoutlocked(st),
                topline(st) /= locked ->
                   tick_case_holding_volume_etc_elapseLTtimeout(st)
               ENDCOND
             ENDCOND
         ELSE
          COND (device(st)`infusionrate < device(st)`vtbi)
                    ->
                  COND
                   topline(st) = locked ->
                       tick_case_infuse_infusionrateLTvtbilocked(st),
                   topline(st) /= locked ->
                        tick_case_infuse_infusionrateLTvtbi(st)
                  ENDCOND,
               (device(st)`infusionrate >= device(st)`vtbi) &
                    NOT device(st)`kvoflag
	            -> tick_case_infuse_infusionrateEQvtbi_notkvoflag(st),
               (device(st)`infusionrate >= device(st)`vtbi) &
                   device(st)`kvoflag
	            -> tick_case_infuse_infusionrateEQvtbi_kvoflag(st)
           ENDCOND
         ENDIF
       ENDIF

% when pressing key1

  per_key1(st: state): bool =
   device(st)`powered_on? & no_button_down(st) &
    (( NOT device(st)`infusing? &
       (((topline(st) = holding OR topline(st) = setrate) AND entrymode(st) = rmode AND
                   fndisp1(st) = fvol) OR
        (((topline(st) = clearsetup & fndisp1(st) = fclear & middisp(st)(drate) &
                  ((device(st)`vtbi /= 0) IMPLIES middisp(st) (dvtbi)) &
                  (((device(st)`vtbi /= 0) OR (device(st)`infusionrate /= 0)) =>
                            middisp(st)(dtime))) OR
          (topline(st) = lockrate & fndisp1(st) = fyes & device(st)`vtbi /= 0 & device(st)`infusionrate /= 0)) & entrymode(st)=nullmode) OR
      ((topline(st) = dispvtbi) &
           ((entrymode(st) = vtmode & fndisp1(st) = fok & middisp(st)(dnewvtbi)) OR
            (entrymode(st) = bagmode & fndisp1(st) = fok) OR
            (entrymode(st) = tbagmode & fndisp1(st) = fok))) OR
       ((topline(st) = vtbitime) & (((entrymode(st) = vttmode) & (fndisp1(st) = fok) &
                                        (device(st)`vtbi /= 0)) OR
                                    (entrymode(st) = ttmode)) & (fndisp1(st) = fok) &
                                     middisp(st)(dnewrate) &
                                     middisp(st)(dnewvtbi) & middisp(st)(dnewtime)) OR
       ((topline(st) = options) & (fndisp1(st) = fok) & (entrymode(st) = qmode)))) OR
    (device(st)`infusing? & ((((topline(st) = dispkvo) OR (topline(st) = infusing)) AND (entrymode(st) = infusemode) & (fndisp1(st) = fvol)) OR ((topline(st) = dispvtbi) &
                      ((entrymode(st) = vtmode & fndisp1(st) = fok & middisp(st)(dnewvtbi)) OR
                        (NOT device(st)`kvoflag & fndisp1(st) = fok & entrymode(st) = bagmode))) OR
                        ((topline(st) = options) & (fndisp1(st) = fok) & (entrymode(st) = qmode) &
                          NOT device(st)`kvoflag &
                          ((optionsmenu(st)(qcursor(st)) /= optionblank) AND
                           (optionsmenu(st)(qcursor(st)) /= setvtbiovertime) AND
                           (optionsmenu(st)(qcursor(st)) /= disableratelock) AND
                           (optionsmenu(st)(qcursor(st)) /= enableratelock))))) )

  key1_case_clearsetup(st: (per_key1)):state =
     st WITH [ topline :=
              COND
                device(st)`infusionrate = 0 -> setrate,
                 ELSE -> holding
               ENDCOND,
      	        middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvol),
                device := reset(device(st)),
                fndisp1 := fvol,
		fndisp2 := fvtbi,
		fndisp3 := fnull,
                entrymode  := rmode ]

  key1_case_infuselocked(st: (per_key1)): state =
       st WITH [ device :=
                  IF per_start(st`device) THEN start(st`device)
                  ELSE st`device
                  ENDIF,
              rlock := TRUE,
              topline := infusing,
              middisp := LAMBDA(x: imid_type):
                           COND x = drate -> TRUE,
                                x = dvtbi -> TRUE,
				x = dvol  -> TRUE,
				x = dtime -> TRUE,
				ELSE -> FALSE ENDCOND,
              fndisp1 := fvol,
              fndisp2 := fvtbi,
              fndisp3 := fnull,
              entrymode  := infusemode,
              runlight := TRUE,
              pauselight := FALSE ]

  key1_case_holdinginfusingdispkvo(st: (per_key1)): state =
      st WITH [ topline := volume,
      	        middisp := LAMBDA(x: imid_type): x = dvol,
                device := resetElapsed(device(st)),
                fndisp1 := fnull,
		fndisp2 := fclear,
		fndisp3 := fquit,
                entrymode  := nullmode ]


  key1_case_dispvtbi_vtmode(st: (per_key1)): state =
                 st WITH [ topline := COND NOT device(st)`infusing? &
                                           device(st)`infusionrate /= 0 -> holding,
                                           NOT device(st)`infusing? &
                                           device(st)`infusionrate = 0 -> setrate,
                                           device(st)`infusing? -> infusing
                                      ENDCOND,
                    	   entrymode := COND NOT device(st)`infusing? -> rmode,
                                           device(st)`infusing? -> infusemode
                                      ENDCOND,
                    	   middisp := LAMBDA(x: imid_type):
			   	       COND (x = dvtbi) OR (x = dtime) -> newvtbi(st) /= 0,
                                	    (x = drate) OR (x = dvol) -> TRUE,
                    			    ELSE -> FALSE ENDCOND,
                    	   fndisp1 := fvol,
			   fndisp2 := fvtbi,
			   fndisp3 := fnull,
			   device  := aug_vtbi(device(st), newvtbi(st)) ]

  key1_case_dispvtbi_bagmode(st: (per_key1)): state =
                  st WITH [ topline := dispvtbi,
	       	            middisp := LAMBDA(x: imid_type): x = dnewvtbi,
                            fndisp1 := fok,
			    fndisp2 := fbags,
			    fndisp3 := fquit,
			    entrymode  := vtmode,
 %-- This has been modified to the actual settings on the Alaris GP
			    newvtbi  := COND bagscursor(st) = 0 -> 0,
                                            bagscursor(st) = 1 -> 50,
                                            bagscursor(st) = 2 -> 100,
                                            bagscursor(st) = 3 -> 200,
                                            bagscursor(st) = 4 -> 250,
                                            bagscursor(st) = 5 -> 500,
                                            bagscursor(st) = 6 -> 1000,
                                            bagscursor(st) = 7 -> 1500,
                                            bagscursor(st) = 8 -> 2000,
                                            bagscursor(st) = mbags -> 3000 ENDCOND,
                            device := resetElapsed(device(st))]

  key1_case_dispvtbi_tbagmode(st: (per_key1)): state =
         LET nvtbi: nonneg_real = COND bagscursor(st) = 0 -> 0,
                                            bagscursor(st) = 1 -> 50,
                                            bagscursor(st) = 2 -> 100,
                                            bagscursor(st) = 3 -> 200,
                                            bagscursor(st) = 4 -> 250,
                                            bagscursor(st) = 5 -> 500,
                                            bagscursor(st) = 6 -> 1000,
                                            bagscursor(st) = 7 -> 1500,
                                            bagscursor(st) = 8 -> 2000,
                                            bagscursor(st) = mbags -> 3000 ENDCOND
          IN
                   st WITH [ topline := vtbitime,
		             middisp := LAMBDA(x: imid_type): (x = dnewvtbi) OR (x = dnewrate) OR (x = dnewtime),
                             fndisp1 := fok,
			     fndisp2 := fbags,
			     fndisp3 := fquit,
			     entrymode  := vttmode,
			     newvtbi  := nvtbi,
                             newrate := IF newtime(st) = 0 THEN 0
			     	     	ELSE nvtbi / newtime(st) ENDIF,
                             device := resetElapsed(device(st))
                           ]



  key1_case_options_dlock(st: (per_key1)): state =
     st WITH [ rlock := NOT rlock(st),
               topline := COND NOT device(st)`infusing? &
                            device(st)`infusionrate /= 0 -> holding,
                               NOT device(st)`infusing? &
                            device(st)`infusionrate = 0 -> holding,
                               device(st)`infusing? -> infusing
                          ENDCOND,
	       entrymode := COND NOT device(st)`infusing? -> rmode,
                               device(st)`infusing? -> infusemode
                          ENDCOND,
               middisp := LAMBDA(x: imid_type):
	       	            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
				 ELSE -> FALSE ENDCOND,
               fndisp1 := fvol,
	       fndisp2 := fvtbi,
	       fndisp3 := fnull,
	       device  := resetElapsed(device(st)) ]

  key1_case_options_dsetvtbi(st: (per_key1)): state =
     st WITH [ topline := vtbitime,
               newvtbi := 0,
               newtime := 1,
               device  := resetElapsed(device(st)),
               middisp := LAMBDA(x: imid_type): (x = dnewrate) OR (x = dnewvtbi) OR (x = dnewtime),
	       fndisp1 := fok,
	       fndisp2 := fbags,
               fndisp3 := fquit,
	       entrymode  := vttmode ]

key1_case_options_dsetvtbilocked(st: (per_key1)): state =
     st WITH [ topline := locked,
               middisp := LAMBDA(x: imid_type): FALSE,
               fndisp1 := fnull,
	       fndisp2 := fnull,
               fndisp3 := fnull,
	       entrymode  := qmode ]

  key1_case_options_ddosing_dsetup_dadjustav_dpdtls(st: (per_key1)): state =
     st WITH [ topline := dispinfo,
               middisp := LAMBDA(x: imid_type): FALSE,
               fndisp1 := fnull,
	       fndisp2 := fnull,
               fndisp3 := fquit,
	       entrymode  := nullmode,
               device  := resetElapsed(device(st)) ]

  key1_case_options_ddisablerate(st: (per_key1)): state =
      st WITH [ rdisabled := NOT rdisabled(st),
                topline := COND NOT device(st)`infusing? &
                               device(st)`infusionrate /= 0 -> holding,
                               NOT device(st)`infusing? &
                               device(st)`infusionrate = 0 -> setrate,
                               device(st)`infusing? -> infusing
                          ENDCOND,
	        entrymode := COND NOT device(st)`infusing? -> rmode,
                               device(st)`infusing? -> infusemode
                          ENDCOND,
                middisp := LAMBDA(x: imid_type):
	       	            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
                                  ELSE -> FALSE ENDCOND,
                fndisp1 := fvol,
	        fndisp2 := fvtbi,
	        fndisp3 := fnull,
	        device  := resetElapsed(device(st)) ]

  key1_case_vtbitime_vttmode(st: (per_key1)): state =
      st WITH [ topline := vtbitime,
                middisp := LAMBDA(x: imid_type): (x = dnewrate) OR (x = dnewvtbi) OR (x = dnewtime),
                device  := resetElapsed(device(st)),
                fndisp1 := fok,
		fndisp2 := fnull,
                fndisp3 := fback,
		entrymode  := ttmode ]

  key1_case_vtbitime_vttmode_vtbiZ(st: (per_key1)): state =
      st WITH [ topline :=
                    COND
                      device(st)`infusionrate = 0 -> setrate,
                      ELSE -> holding
                    ENDCOND,
      	        middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvol),
                device := reset(device(st)),
                fndisp1 := fvol,
		fndisp2 := fvtbi,
		fndisp3 := fnull,
                entrymode  := rmode ]

  key1_case_vtbitime_ttmode_rateNZ(st: (per_key1)): state =
     st WITH [ topline :=  holding,
               middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvtbi) OR (x = dtime) OR (x = dvol),
	       fndisp1 := fvol,
	       fndisp2 := fvtbi,
               fndisp3 := fnull,
	       entrymode  := rmode,
	       device  := modvtbitime(newvtbi(st), newtime(st))(device(st)) ]

   key1_case_vtbitime_ttmode(st: (per_key1)): state =
     LET newdevice = modvtbitime(newvtbi(st), newtime(st))(device(st))
      IN st WITH [
               topline :=
                     COND newdevice`infusionrate = 0 -> setrate,
                          ELSE -> holding ENDCOND,
               middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvtbi) OR (x = dtime) OR (x = dvol),
	       fndisp1 := fvol,
	       fndisp2 := fvtbi,
               fndisp3 := fnull,
	       entrymode  := rmode,
	       device  := newdevice ]

  key1(st:  (per_key1)): state =
        COND
         (topline(st) = holding OR topline(st) = setrate) OR (topline(st) = infusing) OR
         (topline(st) = dispkvo)
               -> key1_case_holdinginfusingdispkvo(st),
         topline(st) = clearsetup ->
                  key1_case_clearsetup(st),
         topline(st) = lockrate ->
                   key1_case_infuselocked(st),
	 topline(st) = dispvtbi ->
               COND entrymode(st) = vtmode    -> key1_case_dispvtbi_vtmode(st),
		    entrymode(st) = bagmode   -> key1_case_dispvtbi_bagmode(st),
                    entrymode(st) = tbagmode  -> key1_case_dispvtbi_tbagmode(st)
        	   ENDCOND,
         topline(st) = options  ->
             COND (optionsmenu(st)(qcursor(st)) = ratelock) OR
                   (optionsmenu(st)(qcursor(st)) = rateunlock)
                        -> key1_case_options_dlock(st),
	 	 (optionsmenu(st)(qcursor(st)) = setvtbiovertime) &
                 NOT rlock(st)
                        -> key1_case_options_dsetvtbi(st),
                  (optionsmenu(st)(qcursor(st)) = setvtbiovertime) & rlock(st)
                        -> key1_case_options_dsetvtbilocked(st),
                   (optionsmenu(st)(qcursor(st)) = disableratelock) OR
                      (optionsmenu(st)(qcursor(st)) = enableratelock)
                        -> key1_case_options_ddisablerate(st),
                    ELSE ->
                     key1_case_options_ddosing_dsetup_dadjustav_dpdtls(st)
         ENDCOND,
         topline(st) = vtbitime & entrymode(st)=vttmode & newvtbi(st) /= 0
                        -> key1_case_vtbitime_vttmode(st),
         topline(st) = vtbitime & entrymode(st)=vttmode & newvtbi(st) = 0
                        -> key1_case_vtbitime_vttmode_vtbiZ(st),
         topline(st) = vtbitime & entrymode(st)=ttmode
                        ->  key1_case_vtbitime_ttmode(st)
        ENDCOND

% when pressing key2

   per_key2(st: state): bool =
   	no_button_down(st) &
               (((topline(st) = holding OR topline(st) = setrate) &
                     entrymode(st) = rmode & fndisp2(st) = fvtbi) OR
                (topline(st) = infusing & fndisp2(st) = fvtbi &
                 entrymode(st) = infusemode & NOT device(st)`kvoflag) OR
                (topline(st) = volume & entrymode(st) = nullmode & fndisp2(st) = fclear) OR
                 ((((topline(st) = dispvtbi) AND (entrymode(st) = vtmode)) OR
                  ((topline(st) = vtbitime) AND (entrymode(st) = vttmode))) AND
                   (fndisp2(st) = fbags)) OR
                 ((topline(st) = setvtbi) AND (entrymode(st) = nullmode) AND (fndisp2(st) = fvtbi)))
               & (device(st)`powered_on?)




  key2_case_holding_infusing(st: (per_key2)): state =
      st WITH [ topline := dispvtbi,
                newvtbi := device(st)`vtbi,
                middisp := LAMBDA(x: imid_type): (x = dnewvtbi),
                fndisp1 := fok,
		fndisp2 := fbags,
		fndisp3 := fquit,
		entrymode := vtmode,
                device  := resetElapsed(device(st)) ]


  key2_case_volume(st: (per_key2)): state =
   st WITH [ topline := COND device(st)`infusing? AND device(st)`powered_on? AND
                                     NOT device(st)`kvoflag -> infusing,
                             device(st)`infusing? AND device(st)`powered_on? AND
                                     device(st)`kvoflag -> dispkvo,
      	     	     	     NOT device(st)`infusing? AND
                                 device(st)`powered_on? AND
                                 device(st)`infusionrate /= 0 -> holding,
                             NOT device(st)`infusing? AND
                                 device(st)`powered_on? AND
                                 device(st)`infusionrate = 0 -> setrate,
                             NOT device(st)`powered_on? -> dispblank ENDCOND,
             entrymode   := COND device(st)`infusing? AND device(st)`powered_on? -> infusemode,
	     	                 NOT device(st)`infusing? AND device(st)`powered_on? -> rmode,
                                 NOT device(st)`powered_on? -> nullmode ENDCOND,

             middisp := LAMBDA(x: imid_type):
	                  COND (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
                               (x = dvol) OR (x = drate) -> TRUE,
			       ELSE -> FALSE ENDCOND,

             device  := clearVolumeinfused(device(st)),

             fndisp1 := fvol,
             fndisp2 := COND device(st)`infusing? AND device(st)`powered_on? AND
                                     device(st)`kvoflag -> fnull,
                             ELSE -> fvtbi ENDCOND,
	     fndisp3 := fnull ]

  key2_case_dispvtbiORvtbitime(st: (per_key2)): state =
      st WITH [ topline := dispvtbi,
                middisp := LAMBDA(x: imid_type): x = dbags,
                bagscursor := midbag,
                fndisp1 := fok,
                fndisp2 := fnull,
		fndisp3 := fback,
		device  := resetElapsed(device(st)),
                entrymode := IF (topline(st) = dispvtbi) THEN bagmode
                             ELSIF topline(st) = vtbitime THEN tbagmode
                             ELSE nullmode ENDIF ]



  key2(st: (per_key2)): state =
        COND
          (topline(st) = holding OR topline(st) = setrate OR topline(st) = infusing OR topline(st) = setvtbi)
                 -> key2_case_holding_infusing(st),
          (topline(st) = volume)
                 -> key2_case_volume(st),
          (topline(st) = dispvtbi OR topline(st) = vtbitime)
                 -> key2_case_dispvtbiORvtbitime(st)
        ENDCOND

% when pressing key3

  per_key3(st: state): bool =
     device(st)`powered_on? & no_button_down(st) &
     (((((topline(st) = vtbidone) AND (fndisp3(st) = fcancel) AND (entrymode(st) = nullmode) AND
           device(st)`kvoflag) OR
        ((topline(st) = dispvtbi) AND
          (((entrymode(st) = vtmode AND fndisp3(st) = fquit) OR
            (entrymode(st) = bagmode AND fndisp3(st) = fback)) AND NOT device(st)`kvoflag)) OR
          ((topline(st) = dispinfo) & (fndisp3(st) = fquit) & (NOT device(st)`kvoflag) &
               (entrymode(st) = nullmode)) OR
           ((topline(st) = options) & (entrymode(st) = qmode) & (fndisp3(st) = fquit) &
                NOT device(st)`kvoflag)) & device(st)`infusing?) OR
       ((((topline(st) = attention) & (fndisp3(st) = fcancel) &
              (entrymode(st) = nullmode)) OR
          (topline(st) = clearsetup & fndisp3(st) = fkeep &
                entrymode(st) = nullmode & middisp(st)(drate)) OR
        (((topline(st) = setvtbi & fndisp3(st) = fcancel & entrymode(st) = nullmode) OR
           (topline(st) = lockrate & fndisp3(st) = fno & NOT device(st)`infusing? &
             device(st)`vtbi /= 0 & device(st)`infusionrate /= 0) OR
          (topline(st) = setnotfitted & fndisp3(st) = fcancel))
            & entrymode(st) = nullmode) OR
        (topline(st) = vtbitime & ((entrymode(st) = vttmode & fndisp3(st) = fquit)
                                  OR (entrymode(st) = ttmode & fndisp3(st) = fback) )) OR
       ((topline(st) = dispvtbi) & ((entrymode(st) = tbagmode & fndisp3(st) = fback) OR
                                     (entrymode(st) = vtmode & fndisp3(st) = fquit) OR
                                    (entrymode(st) = bagmode & fndisp3(st) = fback)) ) OR
        (topline(st) = dispinfo & entrymode(st) = nullmode & fndisp3(st) = fquit) OR
        ((topline(st) = options) & (entrymode(st) = qmode) &
                   (fndisp3(st) = fquit))) & NOT device(st)`infusing?) OR
       (topline(st) = volume & entrymode(st) = nullmode & fndisp3(st) = fquit) OR
       (topline(st) = batterylow & entrymode(st) = nullmode & fndisp3(st) = fcancel))

  key3_case_attention_clearsetup(st: (per_key3)): state =
      st WITH [ topline :=
                 COND device(st)`infusionrate = 0 -> setrate,
                      ELSE -> holding ENDCOND,
                middisp := LAMBDA(x: imid_type):
		            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
			         ELSE -> FALSE ENDCOND,
                fndisp1 := fvol,
		fndisp2 := fvtbi,
                fndisp3 := fnull,
		entrymode  := rmode,
		device  := resetElapsed(device(st)) ]

   key3_case_battery_low(st: (per_key3)): state =
      st WITH [ topline := COND device(st)`infusing? AND NOT device(st)`kvoflag -> infusing,
                                device(st)`infusing? AND device(st)`kvoflag -> dispkvo,
                                NOT device(st)`infusing? & device(st)`infusionrate = 0
                                        -> setrate,
                                ELSE -> holding
                           ENDCOND,
                middisp :=
                  COND NOT device(st)`infusing? ->
                           LAMBDA(x: imid_type):
		            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
			          ELSE -> FALSE ENDCOND,
                        ELSE ->
                          LAMBDA(x: imid_type):
                           COND x = drate -> NOT device(st)`kvoflag,
                                x = dkvorate -> device(st)`kvoflag,
                                (x = dvtbi) OR (x = dvol) OR (x = dtime) -> TRUE,
				ELSE -> FALSE ENDCOND
                        ENDCOND,
                fndisp1 := fvol,
		fndisp2 := COND NOT (device(st)`infusing? AND device(st)`kvoflag) -> fvtbi,
                           ELSE -> fnull ENDCOND,
                fndisp3 := fnull,
		entrymode  := COND NOT device(st)`infusing? -> rmode,
                                   ELSE -> infusemode
                              ENDCOND,
		device  := resetElapsed(device(st)) ]

  key3_case_infuse(st: (per_key3)): state =
         st WITH [ device :=
                  IF per_start(st`device) THEN start(st`device)
                  ELSE st`device
                  ENDIF,
              topline := infusing,
              middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvtbi) OR (x = dvol) OR (x = dtime),
              fndisp1 := fvol,
              fndisp2 := fvtbi,
              fndisp3 := fnull,
              entrymode  := infusemode,
              runlight := TRUE,
              pauselight := FALSE ]

  key3_case_volume(st: (per_key3)): state =
       st WITH [ topline := COND
                              device(st)`infusing? AND device(st)`powered_on? ->
                                        COND NOT device(st)`kvoflag  -> infusing,
       	                                          device(st)`kvoflag -> dispkvo ENDCOND,
                              NOT device(st)`infusing? AND
                                  device(st)`powered_on? & device(st)`infusionrate = 0 ->
                                         setrate,
                              NOT device(st)`infusing? AND device(st)`powered_on?
                                 & device(st)`infusionrate /= 0 -> holding,
                              NOT device(st)`powered_on? -> dispblank
                            ENDCOND,
       	         middisp := LAMBDA(x: imid_type):
		 	      COND (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
                                   x = drate -> NOT(device(st)`infusing? AND device(st)`kvoflag),
				   x = dvol  -> TRUE,
				   x = dkvorate -> device(st)`infusing? AND device(st)`kvoflag,
                                   ELSE -> FALSE
                              ENDCOND,
                 entrymode := COND
                                device(st)`infusing? AND device(st)`powered_on? -> infusemode,
                                NOT device(st)`infusing?  AND device(st)`powered_on? -> rmode,
                                NOT device(st)`powered_on?  -> nullmode
                            ENDCOND,

                 fndisp1 := COND
                              device(st)`powered_on? -> fvol,
                              ELSE -> fnull
                            ENDCOND,
                 fndisp2 := COND
                             device(st)`infusing? AND device(st)`powered_on? AND
                                   NOT device(st)`kvoflag -> fvtbi,
                             NOT device(st)`infusing? AND device(st)`powered_on?
                                         -> fvtbi,
                             ELSE -> fnull
                            ENDCOND,
		 fndisp3 := fnull,
              	 device  := resetElapsed(device(st)) ]

  key3_case_vtbidone(st: (per_key3)): state =
   st WITH [ topline := dispkvo,
             middisp := LAMBDA(x: imid_type): (x = dkvorate) OR (x = dvtbi) OR (x = dvol) OR (x = dtime),
	     fndisp1 := fvol,
	     fndisp2 := fnull,
	     fndisp3 := fnull,
             entrymode := infusemode,
             device  := resetElapsed(device(st)) ]

  key3_case_dispvtbi_vtmode(st: (per_key3)): state =
        st WITH [ topline := COND
                              NOT device(st)`infusing? AND
                                  device(st)`powered_on? &
                                     device(st)`infusionrate = 0 -> setrate,
                              NOT device(st)`infusing? AND
                                  device(st)`powered_on? &
                                     device(st)`infusionrate /= 0 -> holding,
                              NOT device(st)`kvoflag AND device(st)`infusing? AND
                                  device(st)`powered_on? -> infusing,
                              device(st)`kvoflag AND device(st)`infusing? AND
                                  device(st)`powered_on? -> dispkvo,
                              NOT device(st)`powered_on? -> dispblank
                             ENDCOND,
                  device  := resetElapsed(device(st)),
                  middisp := LAMBDA(x: imid_type):
		               COND (x = dvtbi AND (NOT device(st)`kvoflag)) ->
                                         (device(st)`vtbi /= 0),
                                    (x = dvtbi AND device(st)`kvoflag) -> FALSE,
			            x = dtime -> device(st)`vtbi /= 0,
				    (x = drate) OR (x = dvol) -> TRUE,
				    x = dkvorate -> device(st)`kvoflag,
       				    ELSE -> FALSE ENDCOND,
                  fndisp1 := fvol,
		  fndisp2 := COND device(st)`infusing? AND device(st)`kvoflag -> fnull,
                              ELSE -> fvtbi ENDCOND,
		  fndisp3 := fnull,
		  entrymode := COND
                                NOT device(st)`infusing? AND device(st)`powered_on? -> rmode,
                                device(st)`infusing? AND device(st)`powered_on? -> infusemode,
                                NOT device(st)`powered_on? -> nullmode
                               ENDCOND ]

  key3_case_dispvtbi_bagmode(st: (per_key3)): state =
   st WITH [ topline := dispvtbi,
             middisp := LAMBDA(x: imid_type): x = dnewvtbi,
             fndisp1 := fok,
	     fndisp2 := fbags,
	     fndisp3 := fquit,
	     entrymode := vtmode,
	     device  := resetElapsed(device(st)) ]

 key3_case_dispvtbi_tbagmode(st: (per_key3)): state =
   st WITH [ topline := vtbitime,
             middisp := LAMBDA(x: imid_type): (x = dnewtime) OR (x = dnewrate) OR (x = dnewvtbi),
             fndisp1 := fok,
	     fndisp2 := fbags,
	     fndisp3 := fquit,
	     entrymode := vttmode,
	     device  := resetElapsed(device(st)) ]

  key3_case_setvtbi_rate_notfitted(st: (per_key3)): state =
   st WITH [ topline := COND device(st)`infusionrate /= 0 -> holding,
                             ELSE -> setrate ENDCOND,
              middisp := LAMBDA(x: imid_type):
		            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
			         ELSE -> FALSE ENDCOND,
             fndisp1 := fvol,
	     fndisp2 := fvtbi,
             fndisp3 := fnull,
	     entrymode  := rmode,
	     device  := resetElapsed(device(st))]

  key3_case_optionsORdispinfo(st: (per_key3)): state =
   st WITH [ topline := COND NOT device(st)`infusing? &
                              device(st)`infusionrate /= 0-> holding,
                             NOT device(st)`infusing? &
                              device(st)`infusionrate = 0-> setrate,
                             device(st)`infusing? -> infusing
                        ENDCOND,
             middisp := LAMBDA(x: imid_type):
	                 COND (x = drate) OR (x = dvol) -> TRUE,
			      (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
			     ELSE -> FALSE ENDCOND,
              fndisp1 := fvol,
	      fndisp2 := fvtbi,
	      fndisp3 := fnull,
	      entrymode :=  COND NOT device(st)`infusing? AND device(st)`powered_on? -> rmode,
                             device(st)`infusing? AND device(st)`powered_on? -> infusemode,
                             NOT device(st)`powered_on? -> nullmode
                            ENDCOND,
	      device  := resetElapsed(device(st)) ]


  key3_case_vtbitime_vttmode(st: (per_key3)): state =
    st WITH [ topline := COND device(st)`infusionrate /= 0 -> holding,
                              ELSE -> setrate ENDCOND,
              middisp := LAMBDA(x: imid_type):
	                  COND (x = drate) OR (x = dvol) -> TRUE,
                  	       (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
                  	       ELSE -> FALSE ENDCOND,
               fndisp1 := fvol,
	       fndisp2 := fvtbi,
               fndisp3 := fnull,
	       entrymode  := rmode,
	       device  := resetElapsed(device(st)) ]


  key3_case_vtbitime_ttmode(st: (per_key3)): state =
    st WITH [ topline := vtbitime,
              middisp := LAMBDA(x: imid_type): x = dnewrate OR x = dnewvtbi OR x = dnewtime,
              fndisp1 := fok,
	      fndisp2 := fbags,
	      fndisp3 := fquit,
	      entrymode := vttmode ]


  key3(st: (per_key3)): state =
         COND
            (topline(st) = attention OR topline(st) = clearsetup)
                  ->  key3_case_attention_clearsetup(st),
            (topline(st) = batterylow) -> key3_case_battery_low(st),
            (topline(st) = lockrate) ->
                    key3_case_infuse(st),
	    topline(st) = volume
                  ->  key3_case_volume(st),
            topline(st) = vtbidone
                  ->  key3_case_vtbidone(st),
            topline(st) = dispvtbi
                  ->  COND entrymode(st) = vtmode
                             ->  key3_case_dispvtbi_vtmode(st),
	    		   entrymode(st) = bagmode
                             ->  key3_case_dispvtbi_bagmode(st),
                           entrymode(st) = tbagmode
                             -> key3_case_dispvtbi_tbagmode(st) ENDCOND,
            ((topline(st) = setvtbi AND entrymode(st) = nullmode) OR
                (topline(st) = setnotfitted))
                  ->  key3_case_setvtbi_rate_notfitted(st),
	    topline(st) = options OR topline(st) = dispinfo
                  ->  key3_case_optionsORdispinfo(st),
	    topline(st) = vtbitime & entrymode(st) = vttmode
                  ->  key3_case_vtbitime_vttmode(st),
	    topline(st) = vtbitime & entrymode(st) = ttmode
                  ->  key3_case_vtbitime_ttmode(st)
        ENDCOND

% General permission associated with chevron keys

  per_chevron(st: state): bool =
             device(st)`powered_on? &
      (NOT device(st)`infusing? &
         (topline(st) = holding OR topline(st) = setrate) & (entrymode(st) = rmode) &
            middisp(st)(drate) &
            (middisp(st)(dvtbi) = (device(st)`vtbi /= 0)) &
            (middisp(st)(dtime) = (device(st)`vtbi /= 0)) &
           (fndisp1(st) = fvol & fndisp2(st) = fvtbi &
            fndisp3(st) = fnull)) OR
       (device(st)`infusing? &
           (topline(st) = infusing & entrymode(st) = infusemode &
            middisp(st)(drate) & middisp(st)(dtime) & middisp(st)(dvtbi) &
            fndisp1(st) = fvol & fndisp2(st) = fvtbi & fndisp3(st) = fnull)) OR
       ((topline(st) = dispvtbi) &
           (((entrymode(st) = vtmode) & middisp(st)(dnewvtbi) AND
            (fndisp1(st) = fok) & (fndisp2(st) = fbags) &
            (fndisp3(st) = fquit)) OR
           ((entrymode(st) = bagmode) &
           (fndisp1(st) = fok) & (fndisp2(st) = fnull) &
           (fndisp3(st) = fback)))) OR
        (NOT device(st)`infusing? &
           (((topline(st) = dispvtbi) & (entrymode(st) = tbagmode) &
            (fndisp1(st) = fok) & (fndisp2(st) = fnull) &
            (fndisp3(st) = fback)) OR
            ((topline(st) = vtbitime) &
               (((entrymode(st) = vttmode) &
                (fndisp1(st) = fok) & (fndisp2(st) = fbags) &
                (fndisp3(st) = fquit)) OR
               ((entrymode(st) = ttmode) & (fndisp1(st) = fok) &
                (fndisp2(st) = fnull) &  (fndisp3(st) = fback))) &
               (middisp(st)(dnewvtbi) & middisp(st)(dnewtime) &
               middisp(st)(dnewrate))))) OR
            ((topline(st) = options) & (entrymode(st) = qmode) &
               (fndisp1(st) = fok) & (fndisp2(st) = fnull) &
               (fndisp3(st) = fquit))

% specific permissions associated with the chevron keys that use the general permission above

  per_fup(st:state): bool = (no_button_down(st) OR
                                       (which_press(st) = fupb AND pressed(st) < maxpress)) &
                              per_chevron(st)
  per_sup(st: state): bool = (no_button_down(st) OR
                              (which_press(st) = supb AND pressed(st) < maxpress)) &
                              per_chevron(st)
  per_fdown(st: state): bool = (no_button_down(st) OR
                                       (which_press(st) = fdownb AND pressed(st) < maxpress)) &
                              per_chevron(st)
  per_sdown(st: state): bool = (no_button_down(st) OR
                                       (which_press(st) = sdownb AND pressed(st) < maxpress)) &
                              per_chevron(st)

% Fast up chevron key associated with infusion rate

  state_UP_rate(d: steprate, v: irates): irates =
    IF v<100 THEN trim_rate(floor(v) + d)
    ELSIF v>=100 AND v<1000 THEN trim_rate((floor(v/10) + d)*10)
    ELSE trim_rate((floor(v/100) + d) * 100) ENDIF

  fup_case_holding_NOTrlock(d: presstime, st: (per_fup)): state =
    LET v: irates = device(st)`infusionrate,
        s: steprate =
            IF d=0 AND current_sr(st) = small_step AND
               ((v<100 AND fractional(v/10)=0) OR
                (v>100 AND fractional(v/100)=0)) THEN big_step ELSE
                current_sr(st) ENDIF,
        r: irates = state_UP_rate(s, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   topline := COND r = 0 -> setrate,
                                   ELSE -> holding ENDCOND,
                   current_sr := s]

   fup_case_infusing_NOTrlock(d: presstime, st: (per_fup)): state =
    LET v: irates = device(st)`infusionrate,
        s: steprate =
            IF d=0 AND current_sr(st) = small_step AND
               ((v<100 AND fractional(v/10)=0) OR
                (v>100 AND fractional(v/100)=0)) THEN big_step ELSE
                current_sr(st) ENDIF,
        r: irates = state_UP_rate(s, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   current_sr := s]



  fup_case_infusingORholding_rlock(st: (per_fup)): state =
    st WITH [ topline := locked,
              middisp := LAMBDA(x: imid_type): FALSE,
             fndisp1 := fnull,
	     fndisp2 := fnull,
             fndisp3 := fnull,
             device  := resetElapsed(device(st)) ]

% Fast up chevron key associated with volume to be infused

  state_UP_vtbi(d: stepvol, v: ivols): ivols =
    IF v<100 THEN trim_vtbi(floor(v) + d)
    ELSIF v>=100 AND v<1000 THEN trim_vtbi((floor(v/10) + d)*10)
    ELSE trim_vtbi((floor(v/100) + d) * 100) ENDIF

  fup_case_dispvtbi_vtmode(d: presstime, st: (per_fup)): state =
    LET s: stepvol =
            IF d=0 AND current_sv(st) = small_step AND
               ((newvtbi(st) < 100 AND fractional(newvtbi(st)/10)=0) OR
                (newvtbi(st)>100 AND fractional(newvtbi(st)/100)=0)) THEN big_step ELSE
                current_sv(st) ENDIF
        IN
          st WITH [newvtbi := state_UP_vtbi(s, newvtbi(st)),
                   current_sv := s,
                   device  := resetElapsed(device(st))]


  fup_case_vtbitime_vttmode(d: presstime, st: (per_fup)): state =
   LET s: stepvol =
            IF d=0 AND current_sv(st) = small_step AND
               ((newvtbi(st)<100 AND fractional(newvtbi(st)/10)=0) OR
                (newvtbi(st)>100 AND fractional(newvtbi(st)/100)=0)) THEN big_step ELSE
                current_sv(st) ENDIF,
       nv: ivols = state_UP_vtbi(s, newvtbi(st))
        IN
          st WITH [newvtbi := nv,
                   newrate := IF
                               newtime(st) = 0 THEN 0
			      ELSE nv / newtime(st)
                              ENDIF,
                   current_sv := s,
                   device  := resetElapsed(device(st))]

% Fast up chevron key associated with time to infuse

  state_UP_time(s: steptime, v: itimes): itimes =
    trim_time(floor(v/s)*s + s)



  fup_case_vtbitime_ttmode(d: presstime, st: (per_fup)): state =
  LET s: steptime =
            COND d=4 -> 10*small_step,
                 d=3 -> 60,
                 ELSE -> 600
            ENDCOND,
      nt: itimes =  state_UP_time(s, newtime(st))
        IN
          st WITH [newtime := nt,
                   newrate := IF
                               nt = 0 THEN 0
			      ELSE newvtbi(st) / nt
                              ENDIF,
                   current_st := s,
                   device := resetElapsed(device(st))]

  fup_case_dispvtbi_bagmode(st: (per_fup)): state =
    st WITH [ bagscursor := mbags,
              device := resetElapsed(device(st)) ]

  fup_case_dispvtbi_tbagmode(st: (per_fup)): state =
    st WITH [ bagscursor := mbags,
              device := resetElapsed(device(st)) ]

% Fast up chevron key associated with the options menu

  fup_case_options(st: (per_fup)): state =
   st WITH [ qcursor := 0,
             device := resetElapsed(device(st)) ]

% Fast up chevron key

  fup(st: (per_fup)): state =
         LET d: presstime = decrement(pressed(st), 1) IN
         (COND
           (topline(st) = holding OR topline(st) = setrate) &
                NOT rlock(st)
                   -> fup_case_holding_NOTrlock(d, st),
           (topline(st) = infusing) &
                NOT rlock(st)
                   -> fup_case_infusing_NOTrlock(d, st),
           (topline(st) = infusing OR topline(st) = holding OR topline(st) = setrate) &
                    rlock(st)
                   -> fup_case_infusingORholding_rlock(st),
           topline(st) = dispvtbi & entrymode(st) = vtmode
                   -> fup_case_dispvtbi_vtmode(d, st),
           topline(st) = vtbitime & entrymode(st) = vttmode
                   -> fup_case_vtbitime_vttmode(d, st),
           topline(st) = vtbitime & entrymode(st) = ttmode
                   -> fup_case_vtbitime_ttmode(d, st),
           topline(st) = dispvtbi & entrymode(st) = bagmode
                   -> fup_case_dispvtbi_bagmode(st),
           topline(st) = dispvtbi & entrymode(st) = tbagmode
                   -> fup_case_dispvtbi_tbagmode(st),
           topline(st) = options
                   -> fup_case_options(st)

        ENDCOND) WITH [pressed := d,
                      which_press := fupb]

% Slow up chevron key associated with infusion rate

  state_up_rate(d: steprate, v: irates): irates =
     IF    v < 100                 THEN trim_rate( floor((v*10) + d) / 10 )
     ELSIF v >= 100 AND v < 1000 THEN trim_rate( floor((v) + d) )
     ELSE                                 trim_rate( (floor(v/10) + d) * 10 ) ENDIF


  sup_case_holding_NOTrlock(st: (per_sup)): state =
   LET v: irates = device(st)`infusionrate,
       r: irates = state_up_rate(small_step, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   topline := COND r = 0 -> setrate,
                                ELSE -> holding ENDCOND,
                   current_sr := small_step]

  sup_case_infusing_NOTrlock(st: (per_sup)): state =
   LET v: irates = device(st)`infusionrate,
       r: irates = state_up_rate(small_step, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   current_sr := small_step]

  sup_case_infusingORholding_rlock(st: (per_sup)): state =
    st WITH [ topline := locked,
	      middisp := LAMBDA(x: imid_type): FALSE,
              fndisp1 := fnull,
	      fndisp2 := fnull,
              fndisp3 := fnull,
              device := resetElapsed(device(st))]

 % Slow up chevron key associated with volume to be infused

 state_up_vtbi(d: stepvol, v: ivols): ivols =
     IF    v < 100                 THEN trim_vtbi( floor((v*10) + d) / 10 )
     ELSIF v >= 100 AND v < 1000 THEN trim_vtbi( floor((v) + d) )
     ELSE                                 trim_vtbi( (floor(v/10) + d) * 10 ) ENDIF

sup_case_dispvtbi_vtmode(st: (per_sup)): state =
          st WITH [newvtbi := state_up_vtbi(small_step, newvtbi(st)),
                   current_sv := small_step,
                   device  := resetElapsed(device(st))]

  sup_case_vtbitime_vttmode(st: (per_sup)): state =
    LET nv: ivols = state_up_vtbi(small_step, newvtbi(st))
        IN
          st WITH [newvtbi := nv,
                   newrate := IF
                               newtime(st) = 0 THEN 0
			     ELSE nv / newtime(st)
                              ENDIF,
                   current_sv := small_step,
                   device  := resetElapsed(device(st))]

% Slow up chevron key associated with time to infuse

  state_up_time(s: steptime, v: itimes): itimes =
     trim_time(floor(v/s)*s + s)

  sup_case_vtbitime_ttmode(d: presstime, st: {st: state | per_sup(st)}): state =
     LET s: steptime =
            COND
              d=4 -> small_step,
              d=3 -> 10*small_step,
              d=2 -> 60,
              ELSE -> 600
             ENDCOND,
        nt: itimes = state_up_time(s, newtime(st))
        IN
          st WITH [newtime := nt,
                   newrate := IF
                               nt = 0 THEN 0
			      % >>new edit<<
                              %ELSE floor(newvtbi(st) / nt)
                              ELSE newvtbi(st) / nt
                              ENDIF,
                   current_st := small_step,
                   device  := resetElapsed(device(st))]

  sup_case_dispvtbi_bagmode(st: (per_sup)): state =
    st WITH [ bagscursor := COND bagscursor(st) < mbags -> bagscursor(st) + 1,
                                 bagscursor(st) >= mbags -> bagscursor(st) ENDCOND,
              device := resetElapsed(device(st)) ]

  sup_case_dispvtbi_tbagmode(st: (per_sup)): state =
    st WITH [ bagscursor := COND bagscursor(st) < mbags -> bagscursor(st) + 1,
                                 bagscursor(st) >= mbags -> bagscursor(st) ENDCOND,
              device := resetElapsed(device(st)) ]

% Slow up chevron key associated with the options menu

  sup_case_options(st: (per_sup)): state =
    st WITH [ qcursor :=
                IF qcursor(st) = 0 THEN 0
                ELSE qcursor(st) -1
                ENDIF,
              device := resetElapsed(device(st)) ]

  sup(st: (per_sup)): state =
      LET d: presstime = decrement(pressed(st), 1) IN
        (COND
          (topline(st) = holding OR topline(st) = setrate) &
            NOT rlock(st)
               ->  sup_case_holding_NOTrlock(st),
           (topline(st) = infusing) &
            NOT rlock(st)
               ->  sup_case_infusing_NOTrlock(st),
          (topline(st) = infusing OR topline(st) = holding OR topline(st) = setrate)  &
              rlock(st)
               ->  sup_case_infusingORholding_rlock(st),
          (topline(st) = dispvtbi) &
                (entrymode(st) = vtmode)
               ->  sup_case_dispvtbi_vtmode(st),
          (topline(st) = vtbitime) &
             (entrymode(st) = vttmode)
               ->  sup_case_vtbitime_vttmode(st),
          (topline(st) = vtbitime) &
                (entrymode(st) = ttmode)
               ->  sup_case_vtbitime_ttmode(d, st),
          (topline(st) = dispvtbi) &
            (entrymode(st) = bagmode)
               ->  sup_case_dispvtbi_bagmode(st),
          (topline(st) = dispvtbi) & (entrymode(st) = tbagmode)
               ->  sup_case_dispvtbi_tbagmode(st),
          topline(st) = options
               ->  sup_case_options(st)
        ENDCOND) WITH [pressed := d, which_press := supb]

% The fast down button associated with infusion rate
 %-- the conditions for DN are apparently slightly different from those of the other buttons...
  state_DN_rate(d: steprate, v: irates): irates =
     IF    v < 100                THEN trim_rate( ceil_rate(v) - d)
     ELSIF v >= 100 AND v < 1000  THEN trim_rate( (ceil_rate(v/10) - d) * 10 )
     ELSE                                 trim_rate( (ceil_rate(v/100) - d) * 100 ) ENDIF

  fdown_case_holding_NOTrlock(d: presstime, st: (per_fdown)): state =
    LET v: irates = device(st)`infusionrate,
        s: steprate =
            COND
              d=0 AND current_sr(st) = small_step AND
               ((v>10 AND v<100 AND fractional(v/10)=0) OR
                (v>100 AND fractional(v/100)=0)) -> big_step,
              d/=maxpress AND current_sr(st) = big_step AND (v=10 OR v=100) -> small_step,
              ELSE ->  current_sr(st) ENDCOND,
        r: irates = state_DN_rate(s, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   topline := COND r = 0 -> setrate,
                                ELSE -> holding ENDCOND,
                   current_sr := s]

  fdown_case_infusing_NOTrlock(d: presstime, st: (per_fdown)): state =
    LET v: irates = device(st)`infusionrate,
        s: steprate =
            COND
              d=0 AND current_sr(st) = small_step AND
               ((v>10 AND v<100 AND fractional(v/10)=0) OR
                (v>100 AND fractional(v/100)=0)) -> big_step,
              d/=maxpress AND current_sr(st) = big_step AND (v=10 OR v=100) -> small_step,
              ELSE ->  current_sr(st) ENDCOND,
        r: irates = state_DN_rate(s, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   current_sr := s]

  fdown_case_infusingORholding_rlock(st: (per_fdown)): state =
    st WITH [ topline := locked,
              middisp := LAMBDA(x: imid_type): FALSE,
              fndisp1 := fnull,
	      fndisp2 := fnull,
              fndisp3 := fnull,
              device  := resetElapsed(device(st)) ]

% The fast down button associated with volume to be infused

   state_DN_vtbi(d: stepvol, v: ivols): ivols =
     IF    v < 100                THEN trim_vtbi( ceil_vtbi(v) - d)
     ELSIF v >= 100 AND v < 1000  THEN trim_vtbi( (ceil_vtbi(v/10) - d) * 10 )
     ELSE                                 trim_vtbi( (ceil_vtbi(v/100) - d) * 100 ) ENDIF

 fdown_case_dispvtbi_vtmode(d: presstime, st: (per_fdown)): state =
   LET s: stepvol =
            COND
              d=0 AND current_sv(st) = small_step AND
               ((newvtbi(st)>10 AND newvtbi(st)<100 AND fractional(newvtbi(st)/10)=0) OR
                (newvtbi(st)>100 AND fractional(newvtbi(st)/100)=0)) -> big_step,
              d/=maxpress AND current_sv(st) = big_step AND (newvtbi(st)=10 OR newvtbi(st)=100) -> small_step,
              ELSE ->  current_sv(st) ENDCOND
        IN
          st WITH [newvtbi := state_DN_vtbi(s, newvtbi(st)),
                   current_sv := s,
                   device  := resetElapsed(device(st))]


  fdown_case_vtbitime_vttmode(d: presstime, st: (per_fdown)): state =
     LET s: stepvol =
            COND
              d=0 AND current_sv(st) = small_step AND
               ((newvtbi(st)>10 AND newvtbi(st)<100 AND fractional(newvtbi(st)/10)=0) OR
                (newvtbi(st)>100 AND fractional(newvtbi(st)/100)=0)) -> big_step,
              d/=maxpress AND current_sv(st) = big_step AND (newvtbi(st)=10 OR newvtbi(st)=100) -> small_step,
              ELSE ->  current_sv(st) ENDCOND,
          nv: ivols = state_DN_vtbi(s, newvtbi(st))
        IN
          st WITH [newvtbi := nv,
                   newrate := IF
                               newtime(st) = 0 THEN 0
			      ELSE nv / newtime(st)
                              ENDIF,
                   current_sv := s,
                   device  := resetElapsed(device(st))]

% The fast down button associated with time

state_DN_time(s: steptime, v: itimes): itimes =
     trim_time(ceiling(v/s)*s - s)

state_dn_time(s: steptime, v: itimes): itimes =
     trim_time(ceiling(v/s)*s - s)

  fdown_case_vtbitime_ttmode(d: presstime, st: (per_fdown)): state =
   LET s: steptime =
            COND
              d=4 -> 10*small_step,
              d=3 -> 60,
              ELSE -> 600
             ENDCOND,
         nt: itimes = state_DN_time(s, newtime(st))
        IN
          st WITH [newtime := nt,
                   newrate := IF
                               nt = 0 THEN 0
			     ELSE newvtbi(st) / nt
                              ENDIF,
                   current_st := s,
                   device  := resetElapsed(device(st))]


  fdown_case_dispvtbi_bagmode(st: (per_fdown)): state =
   st WITH [ bagscursor := 0,
             device := resetElapsed(device(st)) ]

  fdown_case_dispvtbi_tbagmode(st: (per_fdown)): state =
   st WITH [ bagscursor := 0,
             device := resetElapsed(device(st)) ]

% The fast down button associated with the options menu

  fdown_case_options(st: (per_fdown)): state =
   st WITH [ qcursor :=
               COND device(st)`infusing? AND NOT rdisabled(st) AND
                        rlock(st) -> 3,
                    device(st)`infusing? AND NOT rdisabled(st) AND
                        NOT rlock(st) -> 3,
                    device(st)`infusing? AND rdisabled(st) -> 2,
                    NOT device(st)`infusing? AND rdisabled(st)  -> 5,
                    ELSE -> dpdtls
               ENDCOND,
             device  := resetElapsed(device(st)) ]

% The general fast down button

  fdown(st: (per_fdown)): state =
        LET d: presstime = decrement(pressed(st), 1) IN
        (COND
          ((topline(st)=holding) OR (topline(st)=setrate)) &
                   NOT rlock(st)
               -> fdown_case_holding_NOTrlock(d, st),
          (topline(st) = infusing) &
                   NOT rlock(st)
               -> fdown_case_infusing_NOTrlock(d, st),
          ((topline(st) = infusing) OR (topline(st)=holding) OR
               (topline(st)=setrate)) & rlock(st)
               -> fdown_case_infusingORholding_rlock(st),
          (topline(st) = dispvtbi) & (entrymode(st) = vtmode)
               -> fdown_case_dispvtbi_vtmode(d, st),
          (topline(st) = vtbitime) & (entrymode(st) = vttmode)
               -> fdown_case_vtbitime_vttmode(d, st),
          (topline(st) = vtbitime) & (entrymode(st) = ttmode)
               -> fdown_case_vtbitime_ttmode(d, st),
          (topline(st) = dispvtbi) & (entrymode(st) = bagmode)
               -> fdown_case_dispvtbi_bagmode(st),
          (topline(st) = dispvtbi) & (entrymode(st) = tbagmode)
               -> fdown_case_dispvtbi_tbagmode(st),
          topline(st) = options
               -> fdown_case_options(st)
       ENDCOND) WITH [pressed := d,
                      which_press := fdownb]

% The slow down button associated with infusion rate

 %-- note: dn(100) = 99 (and not 99.9)
  state_dn_rate(d: steprate, v: irates): irates =
     IF    v < 100                THEN trim_rate( (ceil_rate(v*10) - d) / 10 )
     ELSIF v >= 100 AND v < 1000  THEN trim_rate( ceil_rate(v - d) )
     ELSE                                 trim_rate( (ceil_rate(v/10) - d) * 10 ) ENDIF

  sdown_case_holding_NOTrlock(st: (per_sdown)): state =
    LET v: irates = device(st)`infusionrate,
        r: irates = state_dn_rate(small_step, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   topline := COND r = 0 -> setrate,
                                   ELSE -> holding ENDCOND,
                   current_sr := small_step]

  sdown_case_infusing_NOTrlock(st: (per_sdown)): state =
    LET v: irates = device(st)`infusionrate,
        r: irates = state_dn_rate(small_step, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   current_sr := small_step]

  sdown_case_infusingORholding_rlock(st: (per_sdown)): state =
   st WITH [ topline := locked,
             middisp := LAMBDA(x: imid_type): FALSE,
             fndisp1 := fnull,
	     fndisp2 := fnull,
             fndisp3 := fnull,
             device   := resetElapsed(device(st)) ]

% The slow down button associated with volume to be infused
%-- note: dn(100) = 99 (and not 99.9)
  state_dn_vtbi(d: stepvol, v: ivols): ivols =
     IF    v < 100                THEN trim_vtbi( (ceil_vtbi(v*10) - d) / 10 )
     ELSIF v >= 100 AND v < 1000  THEN trim_vtbi( ceil_vtbi(v - d) )
     ELSE                                 trim_vtbi( (ceil_vtbi(v/10) - d) * 10 ) ENDIF


  sdown_case_dispvtbi_vtmode(st: (per_sdown)): state =
          st WITH [newvtbi := state_dn_vtbi(small_step, newvtbi(st)),
                   current_sv := small_step,
                   device  := resetElapsed(device(st))]

  sdown_case_vtbitime_vttmode(st: (per_sdown)): state =
    LET nv: ivols = state_dn_vtbi(small_step, newvtbi(st))
        IN
          st WITH [newvtbi := nv,
                   newrate := IF
                               newtime(st) = 0 THEN 0
			      ELSE nv / newtime(st)
                              ENDIF,
                   current_sv := small_step,
                   device  := resetElapsed(device(st))]

% The slow down button associated with time
  sdown_case_vtbitime_ttmode(d: presstime, st: (per_sdown)): state =
    LET s: steptime =
            COND
              d=4 -> small_step,
              d=3 -> 10*small_step,
              d=2 -> 60,
              ELSE -> 600
             ENDCOND,
        nt: itimes = state_dn_time(s, newtime(st))
        IN
          st WITH [newtime := nt,
                   newrate := IF
                               nt = 0 THEN 0
			      ELSE newvtbi(st) / nt
                              ENDIF,
                   current_st := s,
                   device  := resetElapsed(device(st))]

  sdown_case_dispvtbi_bagmode(st: (per_sdown)): state =
   st WITH [ bagscursor := COND bagscursor(st) > 0 -> bagscursor(st) - 1,
                                bagscursor(st) = 0 -> bagscursor(st) ENDCOND,
             device := resetElapsed(device(st)) ]

  sdown_case_dispvtbi_tbagmode(st: (per_sdown)): state =
   st WITH [ bagscursor := COND bagscursor(st) > 0 -> bagscursor(st) - 1,
                                bagscursor(st) = 0 -> bagscursor(st) ENDCOND,
             device := resetElapsed(device(st)) ]

% The slow down button associated with options menu

  sdown_case_options(st: (per_sdown)): state =
   st WITH [ qcursor := COND
                          qcursor(st) = dpdtls -> qcursor(st),
                          qcursor(st) < dpdtls AND
                             (optionsmenu(st)(qcursor(st)+1) = optionblank)  -> qcursor(st),
                             ELSE -> qcursor(st)+1 ENDCOND,
              device := resetElapsed(device(st)) ]

% The general slow down function

  sdown(st: (per_sdown)): state =
       LET d: presstime = decrement(pressed(st), 1) IN
        (COND
         ((topline(st) = holding) OR (topline(st) = setrate)) &
               NOT rlock(st)
               -> sdown_case_holding_NOTrlock(st),
         (topline(st) = infusing) &
               NOT rlock(st)
               -> sdown_case_infusing_NOTrlock(st),
         ((topline(st) = infusing) OR (topline(st) = holding) OR (topline(st) = setrate)) &
                   rlock(st)
               -> sdown_case_infusingORholding_rlock(st),
         (topline(st) = dispvtbi) & (entrymode(st) = vtmode)
               -> sdown_case_dispvtbi_vtmode(st),
         (topline(st) = vtbitime) & (entrymode(st) = vttmode)
               -> sdown_case_vtbitime_vttmode(st),
         (topline(st) = vtbitime) & (entrymode(st) = ttmode)
               -> sdown_case_vtbitime_ttmode(d, st),
	 (topline(st) = dispvtbi) & (entrymode(st) = bagmode)
               -> sdown_case_dispvtbi_bagmode(st),
         (topline(st) = dispvtbi) & (entrymode(st) = tbagmode)
               -> sdown_case_dispvtbi_tbagmode(st),
         (topline(st) = options)
               -> sdown_case_options(st)
	ENDCOND) WITH [pressed := d,
                       which_press := sdownb]

 % Releasing the chevron keys

 per_release_chevron(st: state): boolean =
            per_chevron(st) OR (topline(st) = locked AND
                   ((entrymode(st) = rmode) OR (entrymode(st) = infusemode)) AND
                   rlock(st))

 per_release_fup(st: state): boolean =
      which_press(st) = fupb AND pressed(st) < maxpress AND per_release_chevron(st)

 release_fup(st:(per_release_fup)): state =
     release_key(st)

 per_release_sup(st: state): boolean =
      which_press(st) = supb AND pressed(st) < maxpress AND per_release_chevron(st)

 release_sup(st:(per_release_sup)): state =
     release_key(st)


 per_release_fdown(st: state): boolean =
      which_press(st) = fdownb AND pressed(st) < maxpress AND per_release_chevron(st)

 release_fdown(st:(per_release_fdown)): state =
     release_key(st)

per_release_sdown(st: state): boolean =
      which_press(st) = sdownb AND pressed(st) < maxpress AND per_release_chevron(st)

 release_sdown(st:(per_release_sdown)): state =
     release_key(st)

%--- General theorems used in the analysis

% QED Run time  = 99.66 secs. 18/1/17
check_chev_sup_permission: LEMMA
 FORALL (st: state):
      per_sup(st) IMPLIES per_release_sup(sup(st))
% QED Run time  = 313.35 secs. 18/1/17
check_chev_fup_permission: LEMMA
   FORALL (st: state):
      per_fup(st) IMPLIES per_release_fup(fup(st))
% QED Run time  = 101.30 secs. 18/1/17
check_chev_sdown_permission: LEMMA
   FORALL (st: state):
      per_sdown(st) IMPLIES per_release_sdown(sdown(st))
% QED Run time  = 538.67 secs. 18/1/17
check_chev_fdown_permission: LEMMA
   FORALL (st: state):
      per_fdown(st) IMPLIES per_release_fdown(fdown(st))

 END alaris_th
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Alaris GP</a></h2>
    <h3>Modules</h3>
    <ul>
        <li><a href="module-alaris_th.html">alaris_th</a></li>
        <li><a href="module-pump_th.html">pump_th</a></li>
        <li><a href="module-types_and_constants_th.html">types_and_constants_th</a></li>
    </ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.0-dev</a> on Wed Jul 12 2017 13:47:14 GMT+0100 (WEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
